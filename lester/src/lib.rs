//! Lester, [Victor]’s cousin, makes raster graphics.
//!
//! This is a reimplementation of [Poppler]’s `pdftocairo` utility program as a Rust library.
//! It loads PDF documents with Poppler
//! and renders (rasterizes) them to in-memory pixel buffers with [cairo].
//! It can then export to PNG.
//!
//! Lester is primarily intended to help test the visual rendering of PDF files generated by Victor.
//! Reimplementing `pdftocairo` enables skipping the overhead of cross-process communication
//! and image compression/decompression.
//! It will also enable extracting (and testing) PDF metadata at the same time as rendering.
//!
//!
//! ## Requirements
//!
//! * [Poppler], with its `glib` wrapper API.
//! * [cairo]
//! * [pkg-config], at build time
//!
//!
//! [Victor]: https://github.com/SimonSapin/victor
//! [Poppler]: https://poppler.freedesktop.org/
//! [cairo]: https://www.cairographics.org/
//! [pkg-config]: https://www.freedesktop.org/wiki/Software/pkg-config/

use cairo_ffi::*;
use std::any::Any;
use std::error::Error as StdError;
use std::ffi::CStr;
use std::fmt;
use std::fs;
use std::io::{self, Read, Write};
use std::marker::PhantomData;
use std::mem;
use std::ops::Range;
use std::os::raw::*;
use std::panic;
use std::path;
use std::slice;
use poppler_ffi::*;

mod cairo_ffi;  // Not public or re-exported
mod poppler_ffi;  // Not public or re-exported

/// A PDF document parsed by Poppler.
pub struct PdfDocument<'data> {
    ptr: *mut PopplerDocument,
    phantom: PhantomData<&'data [u8]>,
}

impl<'data> PdfDocument<'data> {
    /// Parse the given bytes as PDF.
    pub fn from_bytes(bytes: &'data [u8]) -> Result<Self, GlibError> {
        let mut error = 0 as *mut GError;
        let ptr = unsafe {
            poppler_document_new_from_data(
                // Although this function takes *mut c_char rather than *const c_char,
                // that pointer is only passed to Poppler’s `MemStream` abstraction
                // which appears to only provide read access.
                bytes.as_ptr() as *const c_char as *mut c_char,
                bytes.len() as c_int,
                0 as *const c_char,
                &mut error
            )
        };
        if ptr.is_null() {
            Err(GlibError { ptr: error })
        } else {
            Ok(PdfDocument { ptr, phantom: PhantomData })
        }
    }

    /// Make an iterator of the pages in this document.
    ///
    /// The page count can be obtained with `.pages().len()`,
    /// and an arbitrary page with `.pages().nth(index)`.
    pub fn pages<'doc>(&'doc self) -> PagesIter<'doc, 'data> {
        let page_count = unsafe {
            poppler_document_get_n_pages(self.ptr)
        };
        PagesIter {
            doc: self,
            range: 0..page_count
        }
    }

    fn get_page(&self, index: c_int) -> Page<'data> {
        let ptr = unsafe {
            poppler_document_get_page(self.ptr, index)
        };
        assert!(!ptr.is_null());
        Page { ptr, phantom: PhantomData }
    }
}

impl<'data> Drop for PdfDocument<'data> {
    fn drop(&mut self) {
        unsafe {
            g_object_unref(self.ptr as *mut c_void)
        }
    }
}

/// Double-ended exact-size iterator for the pages in a given `PdfDocument`.
pub struct PagesIter<'doc, 'data: 'doc> {
    doc: &'doc PdfDocument<'data>,
    range: Range<c_int>,
}

impl<'doc, 'data> Iterator for PagesIter<'doc, 'data> {
    type Item = Page<'data>;

    fn next(&mut self) -> Option<Self::Item> {
        self.range.next().map(|index| self.doc.get_page(index))
    }

    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        self.range.nth(n).map(|index| self.doc.get_page(index))
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        let len = self.range.len();
        (len, Some(len))
    }
}

impl<'doc, 'data> DoubleEndedIterator for PagesIter<'doc, 'data> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.range.next_back().map(|index| self.doc.get_page(index))
    }
}

impl<'doc, 'data> ExactSizeIterator for PagesIter<'doc, 'data> {
    fn len(&self) -> usize {
        self.range.len()
    }
}

/// A page from a `PdfDocument`.
pub struct Page<'data> {
    ptr: *mut PopplerPage,
    phantom: PhantomData<&'data [u8]>,
}

impl<'data> Page<'data> {
    /// The width and height of this page, in PostScript points.
    ///
    /// One PostScript point is ¹⁄₁₂ inch,
    /// or 0.352<span style="text-decoration: overline">7</span> mm.
    /// It is the base length unit of the PDF file format.
    pub fn size_in_ps_points(&self) -> (f64, f64) {
        let mut width = 0.;
        let mut height = 0.;
        unsafe {
            poppler_page_get_size(self.ptr, &mut width, &mut height)
        }
        (width, height)
    }

    /// Render (rasterize) this page to the given pixel buffer, with the given options.
    pub fn render(&self, surface: &mut ImageSurface, options: RenderOptions) -> Result<(), CairoError> {
        let RenderOptions { dpi_x, dpi_y, antialias, for_printing } = options;
        // PDF’s default unit is the PostScript point, wich is 1/72 inches.
        let scale_x = dpi_x / 72.;
        let scale_y = dpi_y / 72.;
        let context = surface.context()?;
        unsafe {
            cairo_scale(context.ptr, scale_x, scale_y);
            cairo_set_antialias(context.ptr, antialias.to_cairo());
            if for_printing {
                poppler_page_render_for_printing(self.ptr, context.ptr)
            } else {
                poppler_page_render(self.ptr, context.ptr)
            }
            cairo_surface_flush(surface.ptr);
        }
        context.check_status()?;
        Ok(())
    }
}

impl<'data> Drop for Page<'data> {
    fn drop(&mut self) {
        unsafe {
            g_object_unref(self.ptr as *mut c_void)
        }
    }
}

/// Parameters for rendering (rasterization)
///
/// This type implements the `Default` trait.
/// To only change some fields from the default, it can be constructed as:
///
/// ```rust
/// let options = RenderOptions {
///     for_printing: true,
///     ..RenderOptions::default
/// };
/// ```
#[derive(Copy, Clone, Debug)]
pub struct RenderOptions {
    /// The number of pixels per inch in the horizontal direction,
    /// where one inch is 72 PostScript points.
    ///
    /// Since Victor generates PDF such as a `1pt` CSS length is one PostScript point,
    /// a DPI of 96 will make a `1px` CSS length is one rendered pixel.
    /// A DPI of 192 is similar to a “retina” double-density display.
    pub dpi_x: f64,

    /// The number of pixels per inch in the vertical direction.
    /// Typically this is the same as `dpi_x`.
    pub dpi_y: f64,

    /// The antialiasing mode to use for rasterizing text and vector graphics.
    pub antialias: Antialias,

    /// Whether to use `poppler_page_render_for_printing` instead of `poppler_page_render`.
    /// What that does excactly doesn’t seem well-documented.
    pub for_printing: bool,
}

impl Default for RenderOptions {
    fn default() -> Self {
        RenderOptions {
            // Default to CSS '1px' == 1 raster pixel,
            // assuming CSS '1pt' == 1 PostScript point.
            dpi_x: 96.,
            dpi_y: 96.,
            antialias: Antialias::Default,
            for_printing: false,
        }
    }
}

macro_rules! antialias {
    ($( $Variant: ident => $constant: expr, )+) => {
        /// A cairo antialiasing mode.
        ///
        /// See [`cairo_antialias_t`] for the meaning of each value.
        ///
        /// [`cairo_antialias_t`]: https://www.cairographics.org/manual/cairo-cairo-t.html#cairo-antialias-t
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Antialias {
            $(
                $Variant,
            )+
        }

        impl Antialias {
            fn to_cairo(&self) -> cairo_antialias_t {
                match *self {
                    $(
                        Antialias::$Variant => $constant,
                    )+
                }
            }
        }
    }
}

antialias! {
    Default => CAIRO_ANTIALIAS_DEFAULT,
    None => CAIRO_ANTIALIAS_NONE,
    Gray => CAIRO_ANTIALIAS_GRAY,
    Subpixel => CAIRO_ANTIALIAS_SUBPIXEL,
    Fast => CAIRO_ANTIALIAS_FAST,
    Good => CAIRO_ANTIALIAS_GOOD,
    Best => CAIRO_ANTIALIAS_BEST,
}

/// The pixels from an `ImageSurface`
pub struct Argb32Image<'data> {
    pub width: usize,
    pub height: usize,
    pub pixels: &'data mut [u32],
}

/// A cairo “image surface”: an in-memory pixel buffer.
///
/// Only the RGB24 and ARGB32 pixel formats (which have compatible memory representation)
/// are supported.
pub struct ImageSurface {
    ptr: *mut cairo_surface_t,
}

impl Drop for ImageSurface {
    fn drop(&mut self) {
        unsafe {
            cairo_surface_destroy(self.ptr);
        }
    }
}

impl ImageSurface {
    /// Create a new RGB24 image surface of the given size, in pixels
    pub fn new_rgb24(width: usize, height: usize) -> Result<Self, CairoError> {
        Self::new(CAIRO_FORMAT_RGB24, width, height)
    }

    /// Create a new ARGB32 image surface of the given size, in pixels
    pub fn new_argb32(width: usize, height: usize) -> Result<Self, CairoError> {
        Self::new(CAIRO_FORMAT_ARGB32, width, height)
    }

    fn new(format: cairo_format_t, width: usize, height: usize) -> Result<Self, CairoError> {
        unsafe {
            let ptr = cairo_image_surface_create(format, width as _, height as _);
            let surface = ImageSurface { ptr };
            surface.check_status()?;
            Ok(surface)
        }
    }

    fn check_status(&self) -> Result<(), CairoError> {
        CairoError::check(unsafe { cairo_surface_status(self.ptr) })
    }

    fn context(&self) -> Result<CairoContext, CairoError> {
        unsafe {
            let context = CairoContext { ptr: cairo_create(self.ptr) };
            context.check_status()?;
            Ok(context)
        }
    }

    /// Access the pixels of this image surface
    pub fn as_image<'data>(&'data mut self) -> Argb32Image<'data> {
        unsafe {
            let data = cairo_image_surface_get_data(self.ptr);
            let width = cairo_image_surface_get_width(self.ptr);
            let height = cairo_image_surface_get_height(self.ptr);
            let stride = cairo_image_surface_get_stride(self.ptr);
            let format = cairo_image_surface_get_format(self.ptr);
            assert!(format == CAIRO_FORMAT_RGB24 ||
                    format == CAIRO_FORMAT_ARGB32, "Unsupported pixel format");

            // In theory we shouldn’t rely on this.
            // In practice cairo picks a stride that is `width * size_of_pixel`
            // rounded up to 32 bits.
            // ARGB32 and RGB24 both use 32 bit per pixel, so rounding is a no-op.
            assert!(stride == width * (mem::size_of::<u32>() as i32),
                    "Expected 32bit pixel to make width satisfy stride requirements");

            assert!((data as usize) % mem::size_of::<u32>() == 0,
                    "Expected cairo to allocated data aligned to 32 bits");

            // FIXME: checked conversions
            Argb32Image {
                width: width as usize,
                height: height as usize,
                pixels: slice::from_raw_parts_mut(data as *mut u32, (width * height) as usize)
            }
        }
    }

    /// Read and decode a PNG image from the given file name and create an image surface for it.
    pub fn read_from_png_file<P: AsRef<path::Path>>(filename: P) -> Result<Self, Error> {
        Self::read_from_png(io::BufReader::new(fs::File::open(filename)?))
    }

    /// Encode this image to PNG and write it into the file with the given name.
    pub fn write_to_png_file<P: AsRef<path::Path>>(&self, filename: P) -> Result<(), Error> {
        self.write_to_png(io::BufWriter::new(fs::File::create(filename)?))
    }
}

// Private
struct CairoContext {
    ptr: *mut cairo_t,
}

impl CairoContext {
    fn check_status(&self) -> Result<(), CairoError> {
        CairoError::check(unsafe { cairo_status(self.ptr) })
    }
}

impl Drop for CairoContext {
    fn drop(&mut self) {
        unsafe {
            cairo_destroy(self.ptr);
        }
    }
}

macro_rules! with_c_callback {
    (
        $stream: ident : $StreamType: ty : $StreamTrait: ident;
        fn callback($($closure_args: tt)*) -> $ErrorConst: ident $body: block
        ($wrap: expr)($function: ident($($function_args: tt)*))
    ) => {{
        struct ClosureData<Stream> {
            stream: Stream,
            stream_result: Result<(), io::Error>,
            panic_payload: Option<Box<Any + Send + 'static>>
        };
        let mut closure_data = ClosureData {
            stream: $stream,
            stream_result: Ok(()),
            panic_payload: None,
        };
        let closure_data_ptr: *mut ClosureData<$StreamType> = &mut closure_data;

        unsafe extern "C" fn callback<Stream: $StreamTrait>(
            closure_data_ptr: *mut c_void, $($closure_args)*
        ) -> cairo_status_t {
            let panic_result = panic::catch_unwind(|| {
                let closure_data = &mut *(closure_data_ptr as *mut ClosureData<Stream>);
                if closure_data.stream_result.is_err() {
                    return $ErrorConst
                }

                let $stream = &mut closure_data.stream;
                match $body {
                    Ok(()) => {
                        CAIRO_STATUS_SUCCESS
                    }
                    Err(error) => {
                        closure_data.stream_result = Err(error);
                        $ErrorConst
                    }
                }
            });
            match panic_result {
                Ok(value) => value,
                Err(panic_payload) => {
                    let closure_data = &mut *(closure_data_ptr as *mut ClosureData<Stream>);
                    closure_data.panic_payload = Some(panic_payload);
                    $ErrorConst
                }
            }
        }

        let result = unsafe {
            $wrap($function(
                $($function_args)*
                callback::<$StreamType>,
                closure_data_ptr as *mut c_void
            ))
        };
        if let Some(panic_payload) = closure_data.panic_payload {
            panic::resume_unwind(panic_payload)
        }
        closure_data.stream_result?;
        result
    }}
}


impl ImageSurface {
    /// Read and decode a PNG image from the given stream and create an image surface for it.
    ///
    /// Note: this may do many read calls.
    /// If a stream is backed by costly system calls (such as `File` or `TcpStream`),
    /// this constructor will likely perform better with that stream wrapped in `BufReader`.
    pub fn read_from_png<R: Read>(stream: R) -> Result<Self, Error> {
        let surface = with_c_callback! {
            stream: R: Read;
            fn callback(buffer: *mut c_uchar, length: c_uint) -> CAIRO_STATUS_WRITE_ERROR {
                // FIXME: checked conversion
                let slice = slice::from_raw_parts_mut(buffer, length as usize);
                stream.read_exact(slice)
            }
            (|ptr| ImageSurface { ptr })(cairo_image_surface_create_from_png_stream())
        };

        surface.check_status()?;
        Ok(surface)
    }

    /// Encode this image to PNG and write it to the given stream.
    ///
    /// Note: this may do many read calls.
    /// If a stream is backed by costly system calls (such as `File` or `TcpStream`),
    /// this constructor will likely perform better with that stream wrapped in `BufWriter`.
    ///
    /// See also the `write_to_png_file` method.
    pub fn write_to_png<W: Write>(&self, stream: W) -> Result<(), Error> {
        let status = with_c_callback! {
            stream: W: Write;
            fn callback(buffer: *const c_uchar, length: c_uint) -> CAIRO_STATUS_READ_ERROR {
                // FIXME: checked conversion
                let slice = slice::from_raw_parts(buffer, length as usize);
                stream.write_all(slice)
            }
            (|s| s)(cairo_surface_write_to_png_stream(self.ptr,))
        };

        CairoError::check(status)?;
        Ok(())
    }
}

macro_rules! c_error_impls {
    ($T: ty = |$self_: ident| $get_c_str_ptr: expr) => {
        impl StdError for $T {
            fn description(&self) -> &str {
                let cstr = unsafe {
                    let $self_ = self;
                    CStr::from_ptr($get_c_str_ptr)
                };
                cstr.to_str().unwrap()
            }
        }

        impl fmt::Display for $T {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str(self.description())
            }
        }

        impl fmt::Debug for $T {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str(self.description())
            }
        }
    }
}

/// An error returned by cairo
#[derive(Clone)]
pub struct CairoError {
    status: cairo_status_t,
}

impl CairoError {
    fn check(status: cairo_status_t) -> Result<(), Self> {
        if status == CAIRO_STATUS_SUCCESS {
            Ok(())
        } else {
            Err(CairoError { status })
        }
    }
}

c_error_impls! {
    CairoError = |self_| cairo_status_to_string(self_.status)
}

/// A `glib` error returned by Poppler
pub struct GlibError {
    ptr: *mut GError,
}

impl Drop for GlibError {
    fn drop(&mut self) {
        unsafe {
            g_error_free(self.ptr)
        }
    }
}

c_error_impls! {
    GlibError = |self_| (*self_.ptr).message
}

macro_rules! error_enum {
    ($( $Variant: ident ($Type: ty), )+) => {
        /// An error returned by this library
        #[derive(Debug)]
        pub enum Error {
            $(
                $Variant($Type),
            )+
        }

        $(
            impl From<$Type> for Error {
                fn from(e: $Type) -> Self {
                    Error::$Variant(e)
                }
            }
        )+
    }
}

error_enum! {
    Io(io::Error),
    Cairo(CairoError),
    Glib(GlibError),
}
